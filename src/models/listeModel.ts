import pool from '../config/dbconfig';
import { RowDataPacket } from 'mysql2';

export interface Liste {
    listeID?: number;
    listeDateCreation: Date;
    listeDateMAJ: Date;
    estPersonnel: boolean;
    estArchivee?: boolean;
    listeArchivee?: Date | null;
    employeMail: string; // üî• Un seul employ√© responsable de la liste maintenant
    categorieID: number;
}

// üîç R√©cup√©rer toutes les listes
export const getAllListes = async (): Promise<Liste[]> => {
    const [rows] = await pool.query<RowDataPacket[]>('SELECT * FROM liste');
    return rows as Liste[];
};

// üîç R√©cup√©rer une liste par ID
export const getListeById = async (employeMail: string, id: number): Promise<Liste | null> => {
    const [rows] = await pool.query<RowDataPacket[]>(
        `SELECT * FROM liste 
        WHERE listeID = ? 
        AND (estPersonnel = TRUE OR employeMail = ?)`,
        [id, employeMail]
    );
    console.log("ID re√ßu dans getListeById :", id);
    console.log("Type de ID :", typeof id);

    return rows.length > 0 ? (rows[0] as Liste) : null;
};

// üîç R√©cup√©rer toutes les listes accessibles par un employ√©
export const getListesByEmploye = async (employeMail: string): Promise<Liste[]> => {
    try {
        const [adminRows] = await pool.query<RowDataPacket[]>(
            'SELECT isAdmin FROM employe WHERE employeMail = ?',
            [employeMail]
        );

        if (adminRows.length === 0) {
            console.warn(`‚ùå Aucun employ√© trouv√© avec l'e-mail : ${employeMail}`);
            return [];
        }

        const isAdmin = adminRows[0].isAdmin;
        let query = '';
        let params: any[] = [];

        if (isAdmin) {
            query = `
                SELECT * FROM liste 
                WHERE estPersonnel = FALSE OR employeMail = ?`;
            params = [employeMail];
        } else {
            query = `
                SELECT l.* 
                FROM liste l
                LEFT JOIN affecter a ON l.categorieID = a.categorieID
                WHERE l.employeMail = ? OR a.employeMail = ?`;
            params = [employeMail, employeMail];
        }

        const [rows] = await pool.query<RowDataPacket[]>(query, params);
        return rows as Liste[];
    } catch (error) {
        console.error(`‚ùå Erreur dans getListesByEmploye(${employeMail}) :`, error);
        return [];
    }
};

// ‚ûï Ajouter une liste
export const addListe = async (liste: Liste): Promise<void> => {
    const { listeDateCreation, listeDateMAJ, estPersonnel, estArchivee, listeArchivee, employeMail, categorieID } = liste;
    await pool.query(
        'INSERT INTO liste (listeDateCreation, listeDateMAJ, estPersonnel, estArchivee, listeArchivee, employeMail, categorieID) VALUES (?, ?, ?, ?, ?, ?, ?)',
        [listeDateCreation, listeDateMAJ, estPersonnel, estArchivee, listeArchivee || null, employeMail, categorieID]
    );
};

// üîÑ V√©rifier si toutes les t√¢ches d'une liste sont compl√®tes et archiver la liste si n√©cessaire
export const verifierEtArchiverListe = async (listeID: number): Promise<void> => {
    try {
        // V√©rifier si toutes les t√¢ches sont compl√®tes
        const [rows] = await pool.query<RowDataPacket[]>(
            'SELECT COUNT(*) AS incompletes FROM tache WHERE listeID = ? AND tacheEtatCompletion = FALSE',
            [listeID]
        );

        const { incompletes } = rows[0]; // Nombre de t√¢ches non compl√®tes

        if (incompletes === 0) {
            // Si aucune t√¢che incompl√®te, archiver la liste
            await pool.query(
                'UPDATE liste SET estArchivee = TRUE, listeArchivee = NOW() WHERE listeID = ? AND estArchivee = FALSE',
                [listeID]
            );
            console.log(`‚úÖ Liste ${listeID} archiv√©e.`);
        } else {
            // Sinon, s'assurer que la liste n'est pas archiv√©e
            await pool.query(
                'UPDATE liste SET estArchivee = FALSE, listeArchivee = NULL WHERE listeID = ? AND estArchivee = TRUE',
                [listeID]
            );
            console.log(`üîÑ Liste ${listeID} reste active (t√¢ches incompl√®tes : ${incompletes}).`);
        }
    } catch (error) {
        console.error(`‚ùå Erreur lors de la v√©rification d'archivage de la liste ${listeID} :`, error);
    }
};

// ‚ùå Supprimer une liste
export const deleteListe = async (id: number): Promise<void> => {
    await pool.query('DELETE FROM liste WHERE listeID = ?', [id]);
};