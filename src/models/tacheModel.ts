import pool from '../config/dbconfig';
import { RowDataPacket } from 'mysql2';
import { verifierEtArchiverListe } from '../models/listeModel';

export interface Tache {
    tacheID?: number;
    tacheLibelle: string;
    tacheEtatCompletion: boolean;
    tacheDateCompletion?: Date | null;
    tacheEcheance: Date;
    tacheCreation: Date;
    tacheMAJ: Date;
    employeMail: string; // üî• Un seul employ√© responsable de la t√¢che maintenant
    listeID: number;
}

// üîç R√©cup√©rer toutes les t√¢ches
export const getAllTaches = async (): Promise<Tache[]> => {
    const [rows] = await pool.query<RowDataPacket[]>('SELECT * FROM tache');
    return rows as Tache[];
};

// üîç R√©cup√©rer une t√¢che par ID
export const getTacheById = async (employeMail: string, tacheID: number): Promise<Tache | null> => {
    // V√©rifier si l'utilisateur est admin
    const [adminCheck] = await pool.query<RowDataPacket[]>(
        'SELECT isAdmin FROM employe WHERE employeMail = ?',
        [employeMail]
    );

    if (adminCheck.length > 0 && adminCheck[0].isAdmin) {
        // üî• Admin ‚Üí Il peut voir toutes les t√¢ches sauf celles des listes personnelles des autres employ√©s
        const [rows] = await pool.query<RowDataPacket[]>(
            `SELECT t.* 
            FROM tache t 
            JOIN liste l ON t.listeID = l.listeID
            WHERE t.tacheID = ? AND (l.estPersonnel = FALSE OR l.employeMail = ?)`,
            [tacheID, employeMail]
        );
        return rows.length > 0 ? (rows[0] as Tache) : null;
    }

    // üî• Employ√© classique ‚Üí Il ne peut voir que les t√¢ches des listes auxquelles il a acc√®s
    const [rows] = await pool.query<RowDataPacket[]>(
        `SELECT t.*
        FROM tache t
        JOIN liste l ON t.listeID = l.listeID
        LEFT JOIN affecter a ON l.categorieID = a.categorieID
        WHERE t.tacheID = ? AND (l.employeMail = ? OR a.employeMail = ?)`,
        [tacheID, employeMail, employeMail]
    );

    return rows.length > 0 ? (rows[0] as Tache) : null;
};

// üîç R√©cup√©rer toutes les t√¢ches accessibles par un employ√©
export const getTachesByEmploye = async (employeMail: string): Promise<Tache[]> => {
    try {
        const [adminRows] = await pool.query<RowDataPacket[]>(
            'SELECT isAdmin FROM employe WHERE employeMail = ?',
            [employeMail]
        );

        if (adminRows.length === 0) {
            console.warn(`‚ùå Employ√© ${employeMail} non trouv√©`);
            return [];
        }

        const isAdmin = adminRows[0].isAdmin;
        let query = '';
        let params: any[] = [];

        if (isAdmin) {
            query = `
                SELECT t.* 
                FROM tache t
                JOIN liste l ON t.listeID = l.listeID
                WHERE l.estPersonnel = FALSE OR l.employeMail = ?`;
            params = [employeMail];
        } else {
            query = `
                SELECT t.* 
                FROM tache t
                JOIN liste l ON t.listeID = l.listeID
                LEFT JOIN affecter a ON l.categorieID = a.categorieID
                WHERE l.employeMail = ? OR a.employeMail = ?`;
            params = [employeMail, employeMail];
        }

        const [rows] = await pool.query<RowDataPacket[]>(query, params);
        return rows as Tache[];
    } catch (error) {
        console.error(`‚ùå Erreur dans getTachesByEmploye(${employeMail}) :`, error);
        return [];
    }
};



// ‚ûï Ajouter une t√¢che et v√©rifier si la liste doit √™tre archiv√©e
export const addTache = async (tache: Tache): Promise<void> => {
    try {
        const { tacheLibelle, tacheEtatCompletion, tacheDateCompletion, tacheEcheance, tacheCreation, tacheMAJ, employeMail, listeID } = tache;

        await pool.query(
            'INSERT INTO tache (tacheLibelle, tacheEtatCompletion, tacheDateCompletion, tacheEcheance, tacheCreation, tacheMAJ, employeMail, listeID) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
            [tacheLibelle, tacheEtatCompletion, tacheDateCompletion || null, tacheEcheance, tacheCreation, tacheMAJ, employeMail, listeID]
        );

        console.log(`‚úÖ T√¢che ajout√©e pour la liste ${listeID}.`);

        // V√©rifier si la liste doit √™tre archiv√©e
        await verifierEtArchiverListe(listeID);
    } catch (error) {
        console.error("‚ùå Erreur dans addTache :", error);
    }
};

// üîÑ Mettre √† jour une t√¢che et v√©rifier l'archivage de la liste
export const updateTache = async (tacheID: number, updatedTache: Partial<Tache>): Promise<void> => {
    try {
        const { tacheEtatCompletion } = updatedTache;

        // R√©cup√©rer listeID associ√© √† la t√¢che
        const [rows] = await pool.query<RowDataPacket[]>(
            'SELECT listeID FROM tache WHERE tacheID = ?',
            [tacheID]
        );

        if (rows.length === 0) {
            console.log(`‚ùå T√¢che ${tacheID} introuvable.`);
            return;
        }

        const { listeID } = rows[0];

        // Mettre √† jour la t√¢che
        await pool.query(
            'UPDATE tache SET tacheEtatCompletion = ? WHERE tacheID = ?',
            [tacheEtatCompletion, tacheID]
        );

        console.log(`‚úÖ T√¢che ${tacheID} mise √† jour.`);

        // V√©rifier si la liste associ√©e doit √™tre archiv√©e
        await verifierEtArchiverListe(listeID);
    } catch (error) {
        console.error(`‚ùå Erreur dans updateTache pour la t√¢che ${tacheID} :`, error);
    }
};

// ‚ùå Supprimer une t√¢che et v√©rifier l'archivage de la liste
export const deleteTache = async (tacheID: number): Promise<void> => {
    try {
        // R√©cup√©rer listeID avant de supprimer la t√¢che
        const [rows] = await pool.query<RowDataPacket[]>(
            'SELECT listeID FROM tache WHERE tacheID = ?',
            [tacheID]
        );

        if (rows.length === 0) {
            console.log(`‚ùå T√¢che ${tacheID} introuvable.`);
            return;
        }

        const { listeID } = rows[0];

        // Supprimer la t√¢che
        await pool.query('DELETE FROM tache WHERE tacheID = ?', [tacheID]);
        console.log(`‚úÖ T√¢che ${tacheID} supprim√©e.`);

        // V√©rifier si la liste associ√©e doit √™tre archiv√©e
        await verifierEtArchiverListe(listeID);
    } catch (error) {
        console.error(`‚ùå Erreur dans deleteTache pour la t√¢che ${tacheID} :`, error);
    }
};
